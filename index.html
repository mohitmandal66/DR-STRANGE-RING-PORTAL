<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Runic AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: serif; }
        canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; transform: scaleX(-1); }
        video { display: none; }
        #ui { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: gold; z-index: 10; text-shadow: 0 0 10px orange; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">TAP TO CAST SPELLS</div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

<script type="module">
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');

    let thrownRings = [];
    let embers = [];
    let handData = []; 
    let audioCtx = null;

    // --- ANCIENT RUNIC CHARACTERS ---
    const runes = "ᚠᚢᚦᚨᚱᚲᚷᚹᚺᚾᛁᛃᛇᛈᛉᛊᛏᛒᛖᛗᛚᛜᛟᛞ⚡∑∏Ω";

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        document.getElementById('ui').style.opacity = 0;
    }

    function playFireSplash() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const bufferSize = audioCtx.sampleRate * 0.4;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1500, now);
        filter.frequency.exponentialRampToValueAtTime(100, now + 0.4);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
        noise.start();
    }

    function playSpark() {
        if (!audioCtx || Math.random() > 0.4) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'square';
        o.frequency.setValueAtTime(4000 + Math.random()*2000, audioCtx.currentTime);
        g.gain.setValueAtTime(0.04, audioCtx.currentTime);
        g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.03);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.03);
    }

    window.addEventListener('mousedown', initAudio);

    function drawRunicCircle(ctx, x, y, size, rotation, alpha = 1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.globalAlpha = alpha;
        ctx.globalCompositeOperation = 'lighter';

        const gold = `rgba(255, 180, 50, ${alpha})`;
        ctx.shadowBlur = 20;
        ctx.shadowColor = "orange";
        ctx.strokeStyle = gold;
        ctx.fillStyle = gold;
        ctx.lineWidth = 3;

        // 1. Double Outer Rings
        ctx.beginPath(); ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, size * 0.42, 0, Math.PI * 2); ctx.stroke();

        // 2. SPELLING RUNES (The Text)
        ctx.font = `${size * 0.07}px serif`;
        ctx.textAlign = "center";
        const charCount = 12;
        for (let i = 0; i < charCount; i++) {
            ctx.save();
            ctx.rotate((i * Math.PI * 2) / charCount);
            ctx.fillText(runes[i % runes.length], 0, -size * 0.45);
            ctx.restore();
        }

        // 3. Inner Geometry (Geometric Sigil)
        ctx.lineWidth = 1.5;
        for(let r=0; r < 3; r++) {
            ctx.rotate(Math.PI / 3);
            ctx.strokeRect(-size * 0.25, -size * 0.25, size * 0.5, size * 0.5);
        }

        ctx.restore();
    }

    function onResults(results) {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        // Update Embers
        for (let i = embers.length - 1; i >= 0; i--) {
            let p = embers[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            ctx.fillStyle = `rgba(255, ${100 + p.life*155}, 0, ${p.life})`;
            ctx.fillRect(p.x, p.y, p.size, p.size);
            if(p.life <= 0) embers.splice(i, 1);
        }

        // Update Thrown Projectiles
        for (let i = thrownRings.length - 1; i >= 0; i--) {
            let r = thrownRings[i];
            r.x += r.vx; r.y += r.vy; r.rot += 0.08; r.life -= 0.015;
            drawRunicCircle(ctx, r.x, r.y, r.size, r.rot, r.life);
            if(Math.random() > 0.5) playSpark();
            if (r.life <= 0) thrownRings.splice(i, 1);
        }

        if (results.multiHandLandmarks) {
            results.multiHandLandmarks.forEach((landmarks, index) => {
                if(!handData[index]) handData[index] = {lx:0, ly:0, can:true};
                const x = landmarks[9].x * canvasElement.width;
                const y = landmarks[9].y * canvasElement.height;
                const vx = x - handData[index].lx;
                const vy = y - handData[index].ly;
                const speed = Math.sqrt(vx*vx + vy*vy);
                const size = Math.hypot(landmarks[4].x-landmarks[8].x, landmarks[4].y-landmarks[8].y) * canvasElement.width * 3.5;

                if (handData[index].can) {
                    drawRunicCircle(ctx, x, y, size, Date.now() * 0.002);
                    if (speed > 50 && size > 40) {
                        thrownRings.push({ x, y, vx: vx * 0.9, vy: vy * 0.9, size, rot: 0, life: 1.0 });
                        playFireSplash();
                        handData[index].can = false;
                        setTimeout(() => handData[index].can = true, 400);
                    }
                }
                handData[index].lx = x; handData[index].ly = y;
            });
        }
    }

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7 });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    camera.start();
</script>
</body>
</html>
